% Supplementary Material for SWIVL Paper

\section{Supplementary Material}

\subsection{SE(2) Mathematical Foundations}
\label{sec:supp_se2_math}

\subsubsection{SE(2) Lie Group}

The Special Euclidean group in 2D, denoted SE(2), represents rigid body transformations in the plane:
\begin{equation}
\text{SE}(2) = \left\{ T = \begin{bmatrix} R & p \\ 0 & 1 \end{bmatrix} : R \in \text{SO}(2), p \in \mathbb{R}^2 \right\}
\end{equation}

where SO(2) is the special orthogonal group (rotations):
\begin{equation}
\text{SO}(2) = \left\{ R = \begin{bmatrix} \cos\theta & -\sin\theta \\ \sin\theta & \cos\theta \end{bmatrix} : \theta \in [0, 2\pi) \right\}
\end{equation}

A pose in SE(2) can be parameterized as $(x, y, \theta) \in \mathbb{R}^2 \times S^1$.

\subsubsection{se(2) Lie Algebra}

The Lie algebra $\mathfrak{se}(2)$ is the tangent space at the identity:
\begin{equation}
\mathfrak{se}(2) = \left\{ \xi = \begin{bmatrix} \hat{\omega} & v \\ 0 & 0 \end{bmatrix} : \omega \in \mathbb{R}, v \in \mathbb{R}^2 \right\}
\end{equation}

where $\hat{\omega}$ is the skew-symmetric matrix:
\begin{equation}
\hat{\omega} = \begin{bmatrix} 0 & -\omega \\ \omega & 0 \end{bmatrix}
\end{equation}

We use the coordinate representation (Modern Robotics convention):
\begin{equation}
\xi = \begin{bmatrix} \omega \\ v_x \\ v_y \end{bmatrix} \in \mathbb{R}^3
\end{equation}

\noindent Angular velocity first, then linear velocities.

\subsubsection{Exponential Map}

The exponential map $\exp: \mathfrak{se}(2) \to \text{SE}(2)$ is:
\begin{equation}
\exp(\xi) = \begin{bmatrix} e^{\hat{\omega}} & V(\omega) v \\ 0 & 1 \end{bmatrix}
\end{equation}

where:
\begin{equation}
e^{\hat{\omega}} = \begin{bmatrix} \cos\omega & -\sin\omega \\ \sin\omega & \cos\omega \end{bmatrix}
\end{equation}

\begin{equation}
V(\omega) = \begin{cases}
\frac{\sin\omega}{\omega} I + \frac{1-\cos\omega}{\omega} \hat{\omega} & \text{if } \omega \neq 0 \\
I & \text{if } \omega = 0
\end{cases}
\end{equation}

\subsubsection{Logarithm Map}

The logarithm map $\log: \text{SE}(2) \to \mathfrak{se}(2)$ is (MR convention):
\begin{equation}
\log(T) = \begin{bmatrix} \omega \\ V^{-1}(\omega) p \end{bmatrix} = \begin{bmatrix} \omega \\ v_x \\ v_y \end{bmatrix}
\end{equation}

where $\omega = \arctan2(R_{21}, R_{11})$ and:
\begin{equation}
V^{-1}(\omega) = \begin{cases}
\frac{\omega}{2}\cot\frac{\omega}{2} I - \frac{\omega}{2} \hat{\omega} & \text{if } \omega \neq 0 \\
I & \text{if } \omega = 0
\end{cases}
\end{equation}

This is used to compute pose errors (Eq. 1 in main paper).

\textbf{Implementation}: \texttt{src/se2\_math.py:log\_map()}

\subsubsection{Adjoint Transformation}

The adjoint map transforms velocities between frames:
\begin{equation}
\text{Ad}_T: \mathfrak{se}(2) \to \mathfrak{se}(2)
\end{equation}

For $T = (R, p)$ where $p = [p_x, p_y]^T$ (Modern Robotics convention):
\begin{equation}
\text{Ad}_T = \begin{bmatrix}
1 & 0 & 0 \\
p_y & R_{11} & R_{12} \\
-p_x & R_{21} & R_{22}
\end{bmatrix} \in \mathbb{R}^{3 \times 3}
\end{equation}

In coordinate form for $\xi = [\omega, v_x, v_y]^T$:
\begin{equation}
\text{Ad}_T \cdot \xi = \begin{bmatrix}
\omega \\
R v + p_y \omega \\
R v - p_x \omega
\end{bmatrix}
\end{equation}

\noindent The angular velocity is frame-independent, while linear velocity includes the $p \times \omega$ coupling term.

\textbf{Application}: Converts body frame velocity to spatial frame:
\begin{equation}
{}^s V = \text{Ad}_{T_{si}} \cdot {}^i V
\end{equation}

\textbf{Implementation}: \texttt{src/se2\_math.py:body\_to\_world\_velocity()}


\subsection{Frame Transformations}
\label{sec:supp_frames}

\subsubsection{Velocity Transformations}

\paragraph{Body to Spatial (World)}
Given:
- Current pose: $T_{si} = (R, p)$ where $p = [x, y]^T$
- Body frame velocity: ${}^i V = [\omega, v_x^b, v_y^b]^T$ (MR convention!)

Compute spatial velocity (includes $p \times \omega$ term):
\begin{equation}
{}^s V = \begin{bmatrix} \omega \\ R \cdot [v_x^b, v_y^b]^T + [y, -x]^T \omega \end{bmatrix} = \begin{bmatrix} \omega \\ \dot{x} \\ \dot{y} \end{bmatrix}
\end{equation}

\textbf{Implementation}:
\begin{lstlisting}[language=Python]
# src/se2_math.py
def body_to_spatial_twist(pose, body_twist):
    x, y, theta = pose
    omega, vx_b, vy_b = body_twist  # MR convention!

    R = rotation_matrix(theta)
    v_b = np.array([vx_b, vy_b])
    # Include p x omega term!
    v_s = R @ v_b + np.array([y, -x]) * omega

    return np.array([omega, v_s[0], v_s[1]])
\end{lstlisting}

\paragraph{Spatial to Body}
Given:
- Current pose: $T_{si} = (R, p)$ where $p = [x, y]^T$
- Spatial velocity: ${}^s V = [\omega, \dot{x}, \dot{y}]^T$ (MR convention!)

Compute body velocity (subtract $p \times \omega$ term):
\begin{equation}
{}^i V = \begin{bmatrix} \omega \\ R^T \cdot ([\dot{x}, \dot{y}]^T - [y, -x]^T \omega) \end{bmatrix} = \begin{bmatrix} \omega \\ v_x^b \\ v_y^b \end{bmatrix}
\end{equation}

\textbf{Implementation}:
\begin{lstlisting}[language=Python]
# src/se2_math.py
def spatial_to_body_twist(pose, spatial_twist):
    x, y, theta = pose
    omega, vx_s, vy_s = spatial_twist  # MR convention!

    R = rotation_matrix(theta)
    v_s = np.array([vx_s, vy_s])
    # Subtract p x omega term
    v_b = R.T @ (v_s - np.array([y, -x]) * omega)

    return np.array([omega, v_b[0], v_b[1]])
\end{lstlisting}

\subsubsection{Acceleration Transformations}

Accelerations require additional Coriolis terms due to rotating frames.

\paragraph{Spatial to Body}
Given:
- Current pose: $T_{si} = (R, p)$
- Spatial velocity: ${}^s V = [\omega, \dot{x}, \dot{y}]^T$ (MR convention!)
- Spatial acceleration: ${}^s \dot{V} = [\alpha, \ddot{x}, \ddot{y}]^T$ (MR convention!)

Compute body acceleration with Coriolis correction:
\begin{equation}
{}^i \dot{V} = \begin{bmatrix} \alpha \\ R^T \cdot [\ddot{x}, \ddot{y}]^T - \omega \times (R^T \cdot [\dot{x}, \dot{y}]^T) \end{bmatrix}
\end{equation}

where the cross product in 2D is:
\begin{equation}
\omega \times v = \begin{bmatrix} -\omega v_y \\ \omega v_x \end{bmatrix}
\end{equation}

\textbf{Implementation}:
\begin{lstlisting}[language=Python]
# src/se2_math.py
def world_to_body_acceleration(pose, vel_world, accel_world):
    x, y, theta = pose
    v_w = vel_world[:2]
    omega = vel_world[2]
    a_w = accel_world[:2]
    alpha = accel_world[2]

    R = rotation_matrix(theta)

    # Transform linear acceleration
    a_b = R.T @ a_w

    # Coriolis correction: -omega x v_b
    v_b = R.T @ v_w
    coriolis = np.array([-omega * v_b[1], omega * v_b[0]])
    a_b_corrected = a_b - coriolis

    return np.array([a_b_corrected[0], a_b_corrected[1], alpha])
\end{lstlisting}


\subsection{Robot Dynamics in SE(2)}
\label{sec:supp_dynamics}

\subsubsection{Task Space Inertia Matrix}

The task space inertia matrix in body frame is:
\begin{equation}
\Lambda_b = (J_b M^{-1} J_b^T)^{-1}
\end{equation}

where:
\begin{itemize}
    \item $M \in \mathbb{R}^{n \times n}$: Joint space inertia matrix
    \item $J_b \in \mathbb{R}^{3 \times n}$: Body frame Jacobian
\end{itemize}

For a planar 2-DOF arm (translational joints in x, y), following MR convention where twist = $[\omega, v_x, v_y]^T$:
\begin{equation}
M = \begin{bmatrix} m & 0 \\ 0 & m \end{bmatrix}, \quad J_b = \begin{bmatrix} 0 & 1 \\ \cos\theta & 0 \\ \sin\theta & 0 \end{bmatrix}
\end{equation}

This simplifies to (MR convention: rotational inertia first!):
\begin{equation}
\Lambda_b = \text{diag}(I_z, m, m)
\end{equation}

where $I_z$ is the rotational inertia and $m$ is the translational mass.

\textbf{Implementation}:
\begin{lstlisting}[language=Python]
# src/se2_dynamics.py
def compute_task_space_inertia(self, current_pose):
    # For planar translational arms (MR convention!)
    m = self.params.mass
    I = self.params.inertia
    Lambda_b = np.diag([I, m, m])  # Angular inertia first!
    return Lambda_b
\end{lstlisting}

\subsubsection{Coriolis Matrix}

The task space Coriolis matrix accounts for velocity-dependent forces:
\begin{equation}
C_b = J_b M^{-1} C J_b^T - \Lambda_b \dot{J}_b M^{-1} J_b^T
\end{equation}

For the planar case with translational joints, $C_b \approx 0$ as there are no centrifugal/Coriolis effects.

\subsubsection{Gravity Compensation}

Gravity vector in task space:
\begin{equation}
\eta_b = J_b M^{-1} g
\end{equation}

In SE(2) planar setting with horizontal plane, gravity acts perpendicular to the plane, so $\eta_b = 0$ for manipulation tasks.

\textbf{Note}: The implementation includes these terms for generality, even though they may be zero in the specific SE(2) setting.


\subsection{Screw Theory Details}
\label{sec:supp_screw}

\subsubsection{Screw Representation}

A screw $\mathcal{S}$ represents an instantaneous rigid body motion (twist) as rotation about an axis combined with translation along that axis.

In SE(2), following Modern Robotics convention, a unit screw has the form:
\begin{equation}
\mathcal{S} = \begin{bmatrix} s_\omega \\ s_x \\ s_y \end{bmatrix} = \begin{bmatrix} \omega \\ v_x \\ v_y \end{bmatrix} \in \mathfrak{se}(2)
\end{equation}

\noindent Angular component first, then linear components.

\paragraph{Revolute Joint}
For a revolute joint at position $\mathbf{r} = [r_x, r_y]^T$ in the end-effector body frame:
\begin{equation}
\mathcal{S}^{\text{rev}} = \begin{bmatrix} 1 \\ r_y \\ -r_x \end{bmatrix}
\end{equation}

The linear velocity component $[r_y, -r_x]^T$ represents $\mathbf{r} \times \hat{z}$ (perpendicular to position vector).

\paragraph{Prismatic Joint}
For a prismatic joint with direction $\hat{v} = [v_x, v_y]^T$ (unit vector):
\begin{equation}
\mathcal{S}^{\text{pri}} = \begin{bmatrix} 0 \\ v_x \\ v_y \end{bmatrix}
\end{equation}

No angular component (first element = 0), pure translation along the joint direction.

\subsubsection{Configuration Invariance}

A key property: the screw representation in the \textbf{body frame is configuration-invariant}.

\textbf{Proof}: Let $\mathcal{S}_b$ be the screw in body frame and $\mathcal{S}_s$ in spatial frame. They are related by:
\begin{equation}
\mathcal{S}_s = \text{Ad}_{T_{sb}} \cdot \mathcal{S}_b
\end{equation}

As the end-effector moves ($T_{sb}$ changes), $\mathcal{S}_s$ changes, but $\mathcal{S}_b$ remains constant. This is because the joint geometry is fixed relative to the grasped object, which is attached to the end-effector body frame.

\textbf{Practical Implication}: We compute $\mathcal{S}_b$ once at the start of manipulation and reuse it throughout, enabling consistent constraint representation across all configurations.

\textbf{Implementation}:
\begin{lstlisting}[language=Python]
# src/envs/object_manager.py
def get_joint_axis_screws(self):
    """Returns screws in end-effector body frames."""
    # Computed once, remains constant
    B_left = self._compute_screw_in_body_frame(self.ee_left)
    B_right = self._compute_screw_in_body_frame(self.ee_right)
    return B_left, B_right
\end{lstlisting}

\subsubsection{Screw Projection}

Given a twist $V \in \mathfrak{se}(2)$ and unit screw $\mathcal{S}$:

\paragraph{Parallel Projection}
The component along the screw:
\begin{equation}
V_\parallel = (\mathcal{S} \cdot V) \mathcal{S} = \langle \mathcal{S}, V \rangle \mathcal{S}
\end{equation}

where $\langle \cdot, \cdot \rangle$ is the standard inner product in $\mathbb{R}^3$.

\paragraph{Perpendicular Projection}
The component orthogonal to the screw:
\begin{equation}
V_\perp = V - V_\parallel = V - (\mathcal{S} \cdot V) \mathcal{S}
\end{equation}

\paragraph{Orthogonality}
The decomposition satisfies:
\begin{equation}
V = V_\parallel + V_\perp, \quad V_\parallel \perp V_\perp
\end{equation}

Verification:
\begin{equation}
V_\parallel \cdot V_\perp = [(\mathcal{S} \cdot V) \mathcal{S}] \cdot [V - (\mathcal{S} \cdot V) \mathcal{S}] = (\mathcal{S} \cdot V)^2 - (\mathcal{S} \cdot V)^2 = 0
\end{equation}

\textbf{Implementation}:
\begin{lstlisting}[language=Python]
# src/ll_controllers/se2_screw_decomposed_impedance.py
def _decompose_twist(self, twist):
    # Parallel component
    parallel_mag = np.dot(self.screw_axis, twist)
    V_parallel = parallel_mag * self.screw_axis

    # Perpendicular component
    V_perp = twist - V_parallel

    # Verify orthogonality (for debugging)
    assert abs(np.dot(V_parallel, V_perp)) < 1e-6

    return V_parallel, V_perp
\end{lstlisting}


\subsection{Minimum Jerk Trajectory}
\label{sec:supp_traj}

\subsubsection{Quintic Polynomial}

The minimum jerk trajectory uses a quintic (5th order) polynomial:
\begin{equation}
s(t) = 10\tau^3 - 15\tau^4 + 6\tau^5
\end{equation}

where $\tau = t / T$ is normalized time $\in [0, 1]$.

\paragraph{Boundary Conditions}
This polynomial satisfies:
\begin{align}
s(0) = 0, \quad & s(1) = 1 \\
\dot{s}(0) = 0, \quad & \dot{s}(1) = 0 \\
\ddot{s}(0) = 0, \quad & \ddot{s}(1) = 0
\end{align}

Zero velocity and acceleration at both endpoints ensure smooth start and stop.

\paragraph{Derivatives}
\begin{align}
\dot{s}(t) &= \frac{1}{T}(30\tau^2 - 60\tau^3 + 30\tau^4) \\
\ddot{s}(t) &= \frac{1}{T^2}(60\tau - 180\tau^2 + 120\tau^3)
\end{align}

\subsubsection{Pose Interpolation on SE(2)}

Given start pose $T_0$ and end pose $T_1$, we compute the displacement:
\begin{equation}
\Delta = \log(T_0^{-1} T_1) \in \mathfrak{se}(2)
\end{equation}

The interpolated pose at time $t$:
\begin{equation}
T(t) = T_0 \cdot \exp(s(t) \Delta)
\end{equation}

This performs \textbf{geodesic interpolation} on the SE(2) manifold.

\subsubsection{Velocity and Acceleration}

\paragraph{Velocity in Spatial Frame}
\begin{equation}
{}^s V(t) = \dot{s}(t) \Delta
\end{equation}

\paragraph{Velocity in Body Frame}
\begin{equation}
{}^b V(t) = \text{Ad}_{T(t)^{-1}} \cdot {}^s V(t)
\end{equation}

\paragraph{Acceleration}
Spatial frame acceleration:
\begin{equation}
{}^s \dot{V}(t) = \ddot{s}(t) \Delta
\end{equation}

Converted to body frame using the transformation in Sec. \ref{sec:supp_frames}.

\textbf{Implementation}: \texttt{src/trajectory\_generator.py:MinimumJerkTrajectory}


\subsection{Reinforcement Learning Details}
\label{sec:supp_rl}

\subsubsection{PPO Algorithm}

We use Proximal Policy Optimization (PPO) from Stable-Baselines3 with the following hyperparameters:

\begin{table}[h]
\centering
\begin{tabular}{ll}
\hline
\textbf{Parameter} & \textbf{Value} \\
\hline
Learning rate & $3 \times 10^{-4}$ \\
Rollout length & 2048 steps \\
Batch size & 64 \\
Number of epochs & 10 \\
Discount factor $\gamma$ & 0.99 \\
GAE parameter $\lambda$ & 0.95 \\
Clip range & 0.2 \\
Value function coefficient & 0.5 \\
Entropy coefficient & 0.0 \\
Max gradient norm & 0.5 \\
\hline
\end{tabular}
\caption{PPO hyperparameters for impedance variable learning}
\end{table}

\subsubsection{Network Architecture}

\paragraph{Policy Network}
\begin{itemize}
    \item Input: State vector (30D for SE(2) impedance, 30D for screw)
    \item Hidden layers: 2 layers × 256 units
    \item Activation: ReLU
    \item Output: Mean of Gaussian policy (12D or 8D)
    \item Log std: Learned parameter (separate from network)
\end{itemize}

\paragraph{Value Network}
\begin{itemize}
    \item Input: State vector (30D)
    \item Hidden layers: 2 layers × 256 units
    \item Activation: ReLU
    \item Output: Scalar value estimate
\end{itemize}

\subsubsection{Action Space Normalization}

Actions are normalized to $[-1, 1]$ and scaled to physical ranges:

\begin{table}[h]
\centering
\begin{tabular}{lcc}
\hline
\textbf{Parameter} & \textbf{Min} & \textbf{Max} \\
\hline
\multicolumn{3}{c}{\textit{SE(2) Impedance}} \\
$D_{\text{linear}}$ (N·s/m) & 1.0 & 50.0 \\
$D_{\text{angular}}$ (N·m·s/rad) & 0.5 & 20.0 \\
$K_{\text{linear}}$ (N/m) & 10.0 & 200.0 \\
$K_{\text{angular}}$ (N·m/rad) & 5.0 & 100.0 \\
\hline
\multicolumn{3}{c}{\textit{Screw-Decomposed}} \\
$D_\parallel$ (N·s/m or N·m·s/rad) & 1.0 & 50.0 \\
$K_\parallel$ (N/m or N·m/rad) & 5.0 & 100.0 \\
$D_\perp$ (N·s/m or N·m·s/rad) & 5.0 & 100.0 \\
$K_\perp$ (N/m or N·m/rad) & 20.0 & 500.0 \\
\hline
\end{tabular}
\caption{Impedance parameter ranges for action space scaling}
\end{table}

Note: Perpendicular parameters have higher ranges to enforce stiff grasp maintenance.

\subsubsection{Reward Function Weights}

Default reward weights:
\begin{itemize}
    \item $w_{\text{track}} = 1.0$: Tracking error is primary objective
    \item $w_{\text{wrench}} = 0.1$: Force minimization is secondary
    \item $w_{\text{smooth}} = 0.01$: Smoothness is tertiary (regularization)
\end{itemize}

These can be adjusted in \texttt{scripts/configs/rl\_config.yaml}.

\subsubsection{Training Details}

\begin{itemize}
    \item Total timesteps: 1,000,000
    \item Episode length: 1000 RL steps (100 seconds)
    \item Evaluation frequency: Every 10,000 timesteps
    \item Number of evaluation episodes: 5
    \item Parallel environments: 1 (sequential training)
    \item Device: CUDA if available, else CPU
\end{itemize}

Typical training time: 4-6 hours on NVIDIA RTX 3090.


\subsection{Configuration System}
\label{sec:supp_config}

All experiments are specified via \texttt{scripts/configs/rl\_config.yaml}. The complete configuration structure:

\begin{lstlisting}[language=yaml]
# High-Level Policy
hl_policy:
  type: flow_matching  # or diffusion, act
  checkpoint: null
  device: auto

# Low-Level Controller
ll_controller:
  type: se2_impedance  # or screw_decomposed
  robot:
    mass: 1.0
    inertia: 0.1
  se2_impedance:
    min_damping_linear: 1.0
    max_damping_linear: 50.0
    # ... (other bounds)
  screw_decomposed:
    min_damping_parallel: 1.0
    # ... (other bounds)

# Environment
environment:
  name: BiArt
  joint_type: revolute  # or prismatic
  control_dt: 0.01
  policy_dt: 0.1
  max_episode_steps: 1000

# RL Training
rl_training:
  total_timesteps: 1000000
  ppo:
    learning_rate: 3e-4
    n_steps: 2048
    batch_size: 64
    # ... (other PPO params)
  reward:
    tracking_weight: 1.0
    wrench_weight: 0.1
    smoothness_weight: 0.01

# Evaluation
evaluation:
  num_episodes: 50
  save_trajectories: true
  deterministic: true
\end{lstlisting}

This enables:
\begin{itemize}
    \item Systematic ablation across policy/controller types
    \item Reproducible experiments
    \item Easy hyperparameter tuning
\end{itemize}


\subsection{Computational Complexity}
\label{sec:supp_complexity}

\subsubsection{Per-Step Complexity}

\paragraph{SE(2) Impedance Control}
\begin{itemize}
    \item Pose error computation: $O(1)$
    \item Task space dynamics: $O(n)$ where $n$ is number of joints (here $n=2$)
    \item Impedance wrench: $O(1)$
    \item \textbf{Total}: $O(n) \approx O(1)$ for fixed DOF
\end{itemize}

\paragraph{Screw-Decomposed Control}
\begin{itemize}
    \item All of the above: $O(n)$
    \item Screw decomposition (2 projections): $O(1)$
    \item \textbf{Total}: $O(n) \approx O(1)$
\end{itemize}

\paragraph{RL Policy}
\begin{itemize}
    \item Forward pass through 2-layer MLP: $O(d \cdot h)$ where $d=30$ (state dim), $h=256$ (hidden dim)
    \item \textbf{Total}: $O(7680) \approx O(10^4)$ operations
\end{itemize}

\subsubsection{Control Loop Frequency}

With 100 Hz impedance control and 10 Hz RL policy:
\begin{itemize}
    \item Impedance control: $\sim$100 µs per step (lightweight)
    \item RL policy: $\sim$1 ms per step (acceptable for 10 Hz)
    \item Physics simulation: Dominates computation at 240 Hz (PyBullet)
\end{itemize}

The hierarchical architecture is computationally efficient and suitable for real-time control.


\subsection{Code Structure}
\label{sec:supp_code}

Repository structure:
\begin{verbatim}
SWIVL/
├── src/
│   ├── envs/
│   │   ├── biart.py                 # Main environment
│   │   ├── object_manager.py        # Screw extraction
│   │   └── end_effector_manager.py
│   ├── ll_controllers/
│   │   ├── se2_impedance_controller.py       # Alg. 1
│   │   ├── se2_screw_decomposed_impedance.py # Alg. 2
│   │   └── task_space_impedance.py  # Wrapper
│   ├── hl_planners/
│   │   ├── flow_matching.py
│   │   ├── diffusion_policy.py
│   │   └── act.py
│   ├── rl_policy/
│   │   ├── impedance_learning_env.py  # RL environment
│   │   └── ppo_impedance_policy.py    # PPO wrapper
│   ├── se2_math.py                    # SE(2) utilities
│   ├── se2_dynamics.py                # Robot dynamics
│   └── trajectory_generator.py        # Alg. 5
├── scripts/
│   ├── configs/
│   │   └── rl_config.yaml             # All hyperparameters
│   ├── training/
│   │   ├── train_hl_policy.py
│   │   └── train_ll_policy.py         # Alg. 4
│   └── evaluation/
│       └── evaluate_hierarchical.py   # Alg. 3
├── paper/
│   ├── method.tex
│   ├── algorithms.tex
│   ├── code_to_paper_mapping.md
│   └── supplementary.tex              # This file
└── README.md
\end{verbatim}

Total codebase: $\sim$5000 lines of Python.
