% Method Section for SWIVL Paper
\section{Method}
\label{sec:method}

We present SWIVL, a hierarchical control framework that bridges high-level cognitive planners with low-level physically grounded control for bimanual manipulation of articulated objects. Our approach consists of three key components: (1) SE(2) task space impedance control with screw decomposition for object-aware compliance, (2) reference motion field interpretation enabling stable trajectory tracking, and (3) wrench-aware impedance variable learning via reinforcement learning.

\subsection{Problem Formulation}
\label{sec:problem_formulation}

\subsubsection{SE(2) Planar Setting}

We consider bimanual manipulation in SE(2), where two end-effectors cooperatively manipulate a 1-DoF articulated object. Each end-effector pose is represented as $T_{si} \in \text{SE}(2)$, where $s$ denotes the spatial (world) frame and $i \in \{L, R\}$ denotes left or right arm:
\begin{equation}
T_{si} = \begin{bmatrix} R_i & p_i \\ 0 & 1 \end{bmatrix} \in \text{SE}(2), \quad R_i \in \text{SO}(2), \quad p_i \in \mathbb{R}^2
\end{equation}

\noindent The configuration can be equivalently represented as $(x_i, y_i, \theta_i) \in \mathbb{R}^2 \times S^1$.

\subsubsection{Body and Spatial Frames}

For each end-effector, we define two reference frames:
\begin{itemize}
    \item \textbf{Spatial frame} $\{s\}$: World-fixed inertial frame
    \item \textbf{Body frame} $\{i\}$: Attached to end-effector $i$
\end{itemize}

\noindent \textbf{Body twist} (velocity in body frame):
\begin{equation}
{}^i V_i = \begin{bmatrix} v_{i,x}^b \\ v_{i,y}^b \\ \omega_i \end{bmatrix} \in \mathfrak{se}(2)
\end{equation}

\noindent \textbf{Spatial twist} (velocity in world frame):
\begin{equation}
{}^s V_i = \begin{bmatrix} \dot{x}_i \\ \dot{y}_i \\ \omega_i \end{bmatrix} = \text{Ad}_{T_{si}} \cdot {}^i V_i
\end{equation}

\noindent where $\text{Ad}_{T_{si}}$ is the adjoint transformation.

\subsubsection{Wrench Representation}

External forces and moments are measured at each end-effector via 6-axis F/T sensors. In SE(2), the wrench is:
\begin{equation}
{}^i F_i = \begin{bmatrix} f_{i,x}^b \\ f_{i,y}^b \\ \tau_i \end{bmatrix} \in \mathfrak{se}(2)^*
\end{equation}

\noindent measured in the body frame, representing forces along local x, y axes and moment about z-axis.

\subsubsection{Articulated Object Constraints}

The manipulated object has a single revolute or prismatic joint characterized by a \textbf{unit screw axis} $B_i \in \mathfrak{se}(2)$ in each end-effector's body frame:
\begin{equation}
B_i = \begin{bmatrix} \omega_i \\ v_i \end{bmatrix} \in \mathfrak{se}(2), \quad \|B_i\| = 1
\end{equation}

For a revolute joint at distance $d$ from the end-effector:
\begin{equation}
B_i^{\text{rev}} = \begin{bmatrix} 1 \\ 0 \\ d \end{bmatrix}
\end{equation}

For a prismatic joint along direction $\hat{v}$:
\begin{equation}
B_i^{\text{pri}} = \begin{bmatrix} 0 \\ \hat{v} \end{bmatrix}, \quad \|\hat{v}\| = 1
\end{equation}

This screw representation is \textbf{configuration-invariant}: $B_i$ remains constant in the body frame regardless of end-effector pose, enabling consistent constraint encoding across configurations.


\subsection{SE(2) Task Space Impedance Control}
\label{sec:impedance_control}

\subsubsection{Target Dynamics}

Task space impedance control renders desired second-order dynamics in Cartesian space. Given desired pose $T_{si}^d$ and current pose $T_{si}$, we define the \textbf{pose error} $e_i \in \mathfrak{se}(2)$ as:
\begin{equation}
e_i = \log(T_{si}^{-1} T_{si}^d) \in \mathfrak{se}(2)
\label{eq:pose_error}
\end{equation}

The \textbf{target impedance dynamics} is:
\begin{equation}
M_d \cdot {}^i \dot{V}_i + D_d \cdot {}^i V_e + K_d \cdot e_i = {}^i F_{\text{ext}}
\label{eq:target_dynamics}
\end{equation}

\noindent where:
\begin{itemize}
    \item $M_d \in \mathbb{R}^{3 \times 3}$: Desired inertia matrix
    \item $D_d \in \mathbb{R}^{3 \times 3}$: Desired damping matrix
    \item $K_d \in \mathbb{R}^{3 \times 3}$: Desired stiffness matrix
    \item ${}^i V_e = {}^i V_i - {}^i V_i^d$: Velocity error in body frame
    \item ${}^i F_{\text{ext}}$: External wrench
\end{itemize}

\subsubsection{Model Matching for Passivity}

To ensure passivity and stability, we employ \textbf{model matching} by setting:
\begin{equation}
M_d = \Lambda_b
\label{eq:model_matching}
\end{equation}

\noindent where $\Lambda_b \in \mathbb{R}^{3 \times 3}$ is the \textbf{task space inertia matrix} in body frame, computed from robot dynamics:
\begin{equation}
\Lambda_b = (J_b M^{-1} J_b^T)^{-1}
\end{equation}

\noindent with $M$ being the joint space inertia matrix and $J_b$ the body-frame Jacobian.

\subsubsection{Control Law}

The impedance controller computes the required wrench command:
\begin{equation}
\begin{split}
{}^i F_i^{\text{cmd}} = &\ \Lambda_b \cdot {}^i \dot{V}_i^d + C_b \cdot {}^i V_i + \eta_b \\
&\ + D_d \cdot {}^i V_e + K_d \cdot e_i - {}^i F_{\text{ext}}
\end{split}
\label{eq:impedance_wrench}
\end{equation}

\noindent where:
\begin{itemize}
    \item $C_b$: Task space Coriolis matrix (body frame)
    \item $\eta_b$: Gravity compensation (body frame)
    \item ${}^i \dot{V}_i^d$: Desired acceleration (feedforward term)
\end{itemize}

This formulation ensures that the closed-loop system exhibits the target impedance dynamics \eqref{eq:target_dynamics}, providing compliant interaction with the environment.

\subsubsection{Diagonal Impedance Parameters}

In practice, we use diagonal damping and stiffness matrices:
\begin{equation}
D_d = \text{diag}(d_x, d_y, d_\theta), \quad K_d = \text{diag}(k_x, k_y, k_\theta)
\end{equation}

This allows independent tuning of compliance along each degree of freedom in the body frame.


\subsection{Screw-Decomposed Impedance Control}
\label{sec:screw_decomposition}

While standard impedance control provides frame-aligned compliance, articulated object manipulation requires \textbf{directional compliance} that respects object kinematic constraints. We introduce screw-decomposed impedance control that explicitly separates motions into constraint-aligned and constraint-perpendicular subspaces.

\subsubsection{Screw Subspace Decomposition}

Given the unit screw axis $B_i \in \mathfrak{se}(2)$, we decompose the body twist space into:
\begin{equation}
\mathfrak{se}(2) = \text{span}\{B_i\} \oplus \text{span}\{B_i\}^\perp
\end{equation}

\noindent The \textbf{parallel component} (along constraint):
\begin{equation}
V_{\parallel,i} = (B_i \cdot {}^i V_i) B_i \in \text{span}\{B_i\}
\end{equation}

\noindent The \textbf{perpendicular component} (transverse to constraint):
\begin{equation}
V_{\perp,i} = {}^i V_i - V_{\parallel,i} \in \text{span}\{B_i\}^\perp
\end{equation}

Similarly, we decompose the pose error:
\begin{equation}
e_{\parallel,i} = (B_i \cdot e_i) B_i, \quad e_{\perp,i} = e_i - e_{\parallel,i}
\end{equation}

\subsubsection{Directional Impedance Dynamics}

We assign \textbf{independent impedance parameters} to each subspace:
\begin{align}
\text{Parallel (compliant):} \quad & M_\parallel, D_\parallel, K_\parallel \\
\text{Perpendicular (stiff):} \quad & M_\perp, D_\perp, K_\perp
\end{align}

The screw-decomposed impedance dynamics becomes:
\begin{equation}
\begin{split}
M_\parallel \dot{V}_{\parallel,i} + D_\parallel V_{e,\parallel,i} + K_\parallel e_{\parallel,i} &= F_{\parallel,i} \\
M_\perp \dot{V}_{\perp,i} + D_\perp V_{e,\perp,i} + K_\perp e_{\perp,i} &= F_{\perp,i}
\end{split}
\label{eq:screw_dynamics}
\end{equation}

\subsubsection{Control Law}

The screw-decomposed controller computes the wrench command as:
\begin{equation}
\begin{split}
{}^i F_i^{\text{cmd}} = &\ \Lambda_b \cdot {}^i \dot{V}_i^d + C_b \cdot {}^i V_i + \eta_b \\
&\ + D_\parallel V_{e,\parallel,i} + K_\parallel e_{\parallel,i} \\
&\ + D_\perp V_{e,\perp,i} + K_\perp e_{\perp,i} - {}^i F_{\text{ext}}
\end{split}
\label{eq:screw_wrench}
\end{equation}

\subsubsection{Physical Interpretation}

This decomposition enables \textbf{semantic compliance tuning}:
\begin{itemize}
    \item \textbf{Low stiffness parallel} ($K_\parallel \ll K_\perp$): Allows compliant motion along the kinematic constraint (e.g., door rotation)
    \item \textbf{High stiffness perpendicular} ($K_\perp \gg K_\parallel$): Maintains rigid grasp perpendicular to constraint, preventing object slip
\end{itemize}

Unlike diagonal impedance in body frame, screw decomposition provides \textbf{constraint-aware compliance} that remains invariant to end-effector orientation, enabling robust manipulation across varying grasp configurations.


\subsection{Reference Motion Field Interpretation}
\label{sec:reference_motion_field}

We interpret task space impedance control as generating a \textbf{reference motion field}---a stable vector field on SE(2) that guides the end-effector toward desired configurations while respecting dynamic constraints and external interactions.

\subsubsection{Motion Field Formulation}

From the impedance dynamics \eqref{eq:target_dynamics}, we can solve for the desired acceleration:
\begin{equation}
{}^i \dot{V}_i^d = M_d^{-1} \left( {}^i F_{\text{ext}} - D_d \cdot {}^i V_e - K_d \cdot e_i \right)
\label{eq:motion_field}
\end{equation}

This defines a \textbf{second-order dynamical system} where the desired acceleration field depends on:
\begin{itemize}
    \item Current state $(T_{si}, {}^i V_i)$
    \item Target pose $T_{si}^d$
    \item External wrench ${}^i F_{\text{ext}}$
    \item Impedance parameters $(M_d, D_d, K_d)$
\end{itemize}

\subsubsection{Stability Analysis}

Consider the Lyapunov function:
\begin{equation}
\mathcal{L} = \frac{1}{2} {}^i V_e^T M_d {}^i V_e + \frac{1}{2} e_i^T K_d e_i
\end{equation}

Taking the time derivative along system trajectories:
\begin{equation}
\dot{\mathcal{L}} = - {}^i V_e^T D_d {}^i V_e \leq 0
\end{equation}

\noindent This proves that the impedance-controlled system is \textbf{globally asymptotically stable} in the absence of external forces, with the equilibrium at $(e_i = 0, {}^i V_e = 0)$.

\subsubsection{Impedance as Motion Field Shaping}

The impedance parameters $(D_d, K_d)$ shape the reference motion field:
\begin{itemize}
    \item \textbf{Stiffness $K_d$}: Controls the restoring force magnitude, determining how strongly the system is attracted to the target pose
    \item \textbf{Damping $D_d$}: Controls energy dissipation, affecting overshoot and settling time
\end{itemize}

By learning these parameters, we can \textbf{adapt the motion field geometry} to task requirements---achieving soft compliance for force-sensitive insertion or stiff tracking for precise positioning.

\subsubsection{Wrench-Modulated Flow}

External wrenches ${}^i F_{\text{ext}}$ act as \textbf{flow perturbations} that deflect the motion field. The impedance parameters determine the system's responsiveness:
\begin{equation}
\Delta {}^i \dot{V}_i^d = M_d^{-1} {}^i F_{\text{ext}}
\end{equation}

Lower impedance (smaller $K_d$, $D_d$) results in \textbf{larger deflections}, enabling compliant adaptation to contact forces---critical for suppressing internal forces in bimanual manipulation.


\subsection{Impedance Variable Learning via Reinforcement Learning}
\label{sec:rl_learning}

While impedance control provides a principled low-level controller, \textbf{selecting appropriate impedance parameters} for bimanual manipulation is challenging. Fixed gains cannot adapt to varying contact states, object geometries, or force interactions. We propose learning a \textbf{wrench-aware impedance variable policy} via reinforcement learning.

\subsubsection{State Space}

The RL policy observes:
\begin{equation}
s_t = \left[ {}^L F_{\text{ext}}, {}^R F_{\text{ext}}, T_{sL}, T_{sR}, {}^L V_L, {}^R V_R, T_{sL}^d, T_{sR}^d, {}^L V_L^d, {}^R V_R^d \right]
\label{eq:rl_state}
\end{equation}

\noindent This 30-dimensional state includes:
\begin{itemize}
    \item External wrenches (6D): Force/torque feedback
    \item Current poses and twists (12D): End-effector kinematics
    \item Desired poses and twists (12D): High-level trajectory targets
\end{itemize}

The wrench signals provide critical information about inter-arm force coupling and contact states.

\subsubsection{Action Space}

\paragraph{SE(2) Impedance Controller}
The policy outputs diagonal impedance parameters:
\begin{equation}
a_t = [d_x^L, d_y^L, d_\theta^L, k_x^L, k_y^L, k_\theta^L, d_x^R, d_y^R, d_\theta^R, k_x^R, k_y^R, k_\theta^R]
\label{eq:action_se2}
\end{equation}

Actions are normalized to $[-1, 1]$ and scaled to bounds:
\begin{align}
D_d &\in [D_{\min}, D_{\max}] = [1, 50] \text{ N路s/m (linear)}, [0.5, 20] \text{ N路m路s/rad (angular)} \\
K_d &\in [K_{\min}, K_{\max}] = [10, 200] \text{ N/m (linear)}, [5, 100] \text{ N路m/rad (angular)}
\end{align}

\paragraph{Screw-Decomposed Controller}
For screw-decomposed impedance, the action space is 8-dimensional:
\begin{equation}
a_t = [D_\parallel^L, K_\parallel^L, D_\perp^L, K_\perp^L, D_\parallel^R, K_\parallel^R, D_\perp^R, K_\perp^R]
\label{eq:action_screw}
\end{equation}

with bounds:
\begin{align}
D_\parallel &\in [1, 50], \quad K_\parallel \in [5, 100] \quad \text{(compliant)} \\
D_\perp &\in [5, 100], \quad K_\perp \in [20, 500] \quad \text{(stiff)}
\end{align}

\subsubsection{Reward Function}

The reward encourages tracking accuracy while minimizing internal forces:
\begin{equation}
r_t = -w_{\text{track}} \cdot \mathcal{L}_{\text{track}} - w_{\text{wrench}} \cdot \mathcal{L}_{\text{wrench}} - w_{\text{smooth}} \cdot \mathcal{L}_{\text{smooth}}
\label{eq:reward}
\end{equation}

\paragraph{Tracking Error}
\begin{equation}
\mathcal{L}_{\text{track}} = \sum_{i \in \{L,R\}} \left( \|e_i\|_2 + 0.1 \cdot \|{}^i V_{e,i}\|_2 \right)
\end{equation}

\paragraph{Wrench Penalty}
\begin{equation}
\mathcal{L}_{\text{wrench}} = \sum_{i \in \{L,R\}} \|{}^i F_{\text{ext},i}\|_2
\end{equation}

This term encourages the policy to select low stiffness when external forces are high, enabling compliant force adaptation.

\paragraph{Smoothness Penalty}
\begin{equation}
\mathcal{L}_{\text{smooth}} = \|a_t - a_{t-1}\|_2
\end{equation}

This prevents abrupt impedance changes that could destabilize the system.

Default weights: $w_{\text{track}} = 1.0$, $w_{\text{wrench}} = 0.1$, $w_{\text{smooth}} = 0.01$.

\subsubsection{Training with PPO}

We train the impedance policy using Proximal Policy Optimization (PPO) with:
\begin{itemize}
    \item Policy network: 2-layer MLP with 256 hidden units
    \item Learning rate: $3 \times 10^{-4}$
    \item Training timesteps: 1M
    \item Rollout length: 2048 steps
    \item Batch size: 64
    \item GAE: $\lambda = 0.95$
\end{itemize}

The hierarchical control loop operates at:
\begin{itemize}
    \item Low-level impedance control: 100 Hz
    \item RL policy updates: 10 Hz
    \item High-level planner: 10 Hz
\end{itemize}

\subsubsection{Controller-Agnostic Learning}

Critically, the RL policy is trained to work with \textbf{any impedance controller type} (standard SE(2) or screw-decomposed) by simply changing the configuration. This enables systematic comparison of controller architectures while maintaining consistent learning objectives.


\subsection{Hierarchical Control Architecture}
\label{sec:hierarchical_control}

SWIVL employs a \textbf{three-level hierarchical architecture} that decouples cognitive task planning from physical control execution.

\subsubsection{Level 1: High-Level Planner (Cognitive Intelligence)}

The high-level planner generates desired end-effector poses $\{T_{sL}^d(t), T_{sR}^d(t)\}$ at 10 Hz based on:
\begin{itemize}
    \item Visual observations (RGB images, point clouds)
    \item Task objectives (open door, transport object)
    \item Semantic understanding (object affordances, grasp points)
\end{itemize}

SWIVL is compatible with \textbf{any high-level planner}:
\begin{itemize}
    \item \textbf{Behavior cloning}: Flow Matching, Diffusion Policy, ACT
    \item \textbf{Teleoperation}: Keyboard, VR, haptic devices
    \item \textbf{Foundation models}: VLA-based policies (future work)
\end{itemize}

Importantly, the high-level planner does \textbf{not} reason about:
\begin{itemize}
    \item Object kinematic constraints
    \item Inter-arm force interactions
    \item Impedance parameters
\end{itemize}

These physical considerations are handled by the lower levels.

\subsubsection{Level 2: Trajectory Generator}

Raw pose commands from the high-level planner are often discrete and may lack smoothness. We generate \textbf{minimum jerk trajectories} between consecutive waypoints:
\begin{equation}
T_{si}^d(t) = \text{MinJerk}(T_{si}^{\text{start}}, T_{si}^{\text{goal}}, t; \tau)
\end{equation}

where $\tau = 1$ second is the interpolation duration. This provides smooth desired poses, velocities, and accelerations:
\begin{equation}
\left\{ T_{si}^d(t), {}^i V_i^d(t), {}^i \dot{V}_i^d(t) \right\}
\end{equation}

enabling feedforward terms in the impedance controller.

\subsubsection{Level 3: Low-Level Controller (Physical Intelligence)}

The low-level layer consists of:
\begin{enumerate}
    \item \textbf{RL Impedance Policy}: Outputs impedance parameters $a_t$ based on state $s_t$
    \item \textbf{Impedance Controller}: Computes wrench commands ${}^i F_i^{\text{cmd}}$ using \eqref{eq:impedance_wrench} or \eqref{eq:screw_wrench}
\end{enumerate}

This layer ensures:
\begin{itemize}
    \item \textbf{Stability}: Passivity-guaranteed impedance control
    \item \textbf{Compliance}: Wrench-aware force adaptation
    \item \textbf{Constraint satisfaction}: Screw-aligned directional compliance
\end{itemize}

\subsubsection{Information Flow}

The complete pipeline:
\begin{equation}
\begin{aligned}
& \text{Visual Obs} \xrightarrow{\text{HL Planner}} T_{si}^d \\
& T_{si}^d \xrightarrow{\text{Traj Gen}} \{T_{si}^d(t), {}^i V_i^d(t), {}^i \dot{V}_i^d(t)\} \\
& \{s_t, T_{si}^d(t)\} \xrightarrow{\text{RL Policy}} a_t = \{D_d, K_d\} \\
& \{T_{si}^d(t), {}^i V_i^d(t), a_t, {}^i F_{\text{ext}}\} \xrightarrow{\text{Impedance Ctrl}} {}^i F_i^{\text{cmd}} \\
& {}^i F_i^{\text{cmd}} \xrightarrow{\text{Robot}} T_{si}(t+\Delta t)
\end{aligned}
\end{equation}

\subsubsection{Benefits of Hierarchical Decomposition}

\begin{enumerate}
    \item \textbf{Modularity}: Each level can be trained/improved independently
    \item \textbf{Generalization}: RL policy generalizes across planners and tasks
    \item \textbf{Interpretability}: Clear separation of cognitive and physical reasoning
    \item \textbf{Safety}: Impedance control guarantees stability regardless of planner output
\end{enumerate}

This architecture enables SWIVL to operate as a \textbf{universal low-level control stack} beneath arbitrary cognitive planners, bridging the gap between high-level task understanding and low-level physical execution.


\subsection{Implementation Details}
\label{sec:implementation}

\subsubsection{SE(2) Planar Simulation Environment}

We implement a PyBullet-based SE(2) bimanual manipulation environment (BiArt) with:
\begin{itemize}
    \item Two planar 2-DOF arms (x, y translation)
    \item 1-DOF articulated object (revolute or prismatic joint)
    \item 6-axis F/T sensors at end-effectors
    \item Physics timestep: 240 Hz
\end{itemize}

\subsubsection{Controller Implementation}

Both impedance controllers are implemented with:
\begin{itemize}
    \item Model matching: $M_d = \Lambda_b$ computed from robot Jacobian
    \item Dynamics compensation: Coriolis ($C_b$) and gravity ($\eta_b$) terms
    \item Frame consistency: All computations in body frame
\end{itemize}

Screw axis extraction from object geometry is performed once per episode reset.

\subsubsection{Configuration System}

All training/evaluation parameters are specified in YAML configuration files:
\begin{lstlisting}[language=yaml]
hl_policy:
  type: flow_matching  # or diffusion, act

ll_controller:
  type: se2_impedance  # or screw_decomposed

rl_training:
  total_timesteps: 1000000
  ppo:
    learning_rate: 3e-4
    n_steps: 2048
\end{lstlisting}

This enables systematic ablation across policy types and controller architectures.

\subsubsection{Training Infrastructure}

\begin{itemize}
    \item HL policy training: Imitation learning from demonstrations
    \item LL policy training: PPO in gym environment with hierarchical wrapper
    \item Evaluation: Hierarchical pipeline testing with trajectory logging
\end{itemize}

All code is available at: \texttt{https://github.com/[anonymous]/SWIVL}


\subsection{Summary}

SWIVL provides a complete framework for bimanual manipulation of articulated objects:
\begin{enumerate}
    \item \textbf{SE(2) impedance control} with model matching ensures stable, compliant interaction
    \item \textbf{Screw decomposition} enables object-aware directional compliance
    \item \textbf{Reference motion field} interpretation provides theoretical understanding
    \item \textbf{RL-learned impedance policy} adapts compliance based on wrench feedback
    \item \textbf{Hierarchical architecture} decouples cognitive planning from physical execution
\end{enumerate}

This combination of explicit physical modeling and learned adaptation enables robust force-compliant manipulation that generalizes across tasks, planners, and object geometries.
