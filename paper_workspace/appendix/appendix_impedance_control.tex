% Appendix: Impedance Control on SE(3)
\section{Impedance Control on SE(3)}
\label{app:impedance}

This appendix provides the geometric foundations underlying SWIVL's twist-driven impedance control (Section~\ref{sec:screw_decomposed_control}). We derive the classical SE(3) impedance formulation from energy principles, identify the nonlinear pose-error Jacobian $J_{\mathcal{E}}$ as a key complexity, and show how SWIVL's approach bypasses this challenge by incorporating pose errors directly into reference twists.

%==============================================================================
\subsection{Notation}
\label{app:notation}
%==============================================================================

We adopt the following notation consistent with the main text:
\begin{itemize}
    \item $T_{sb} = (R_{sb}, p_{sb}) \in \mathrm{SE}(3)$: Current end-effector pose (body frame $\{b\}$ w.r.t.\ spatial frame $\{s\}$)
    \item $T_{sd} = (R_{sd}, p_{sd}) \in \mathrm{SE}(3)$: Desired end-effector pose (desired frame $\{d\}$)
    \item $T_{bd} = T_{sb}^{-1} T_{sd}$: Relative transformation from current to desired frame
    \item ${}^b\mathcal{V}_b = (\omega_b, v_b) \in \mathbb{R}^6 \cong \mathfrak{se}(3)$: Current body twist
    \item ${}^d\mathcal{V}_d = (\omega_d, v_d)$: Desired body twist expressed in frame $\{d\}$
    \item $\mathcal{E} \in \mathbb{R}^6$: Weighted pose error vector
    \item $\mathcal{F} \in \mathbb{R}^6 \cong \mathfrak{se}(3)^*$: Wrench (moment, force)
    \item $\alpha \in \mathbb{R}^+$: Characteristic length weighting rotation vs.\ translation
    \item $[\cdot]_\times$: Skew-symmetric matrix representation of $\mathbb{R}^3$
\end{itemize}

%==============================================================================
\subsection{Metric Tensor on $\mathfrak{se}(3)$}
\label{app:metric}
%==============================================================================

A geometrically consistent impedance controller requires a proper notion of distance on SE(3). We begin by defining an inner product on $\mathfrak{se}(3)$ with clear physical interpretation.

\subsubsection{Inner Product as Kinetic Energy}

For twists $\mathcal{V}_1 = (\omega_1, v_1)$ and $\mathcal{V}_2 = (\omega_2, v_2)$ in $\mathfrak{se}(3)$, we define the inner product:
\begin{equation}
\langle \mathcal{V}_1, \mathcal{V}_2 \rangle_G = \frac{\alpha^2}{2} \mathrm{tr}([\omega_1]_\times^\top [\omega_2]_\times) + v_1^\top v_2 = \alpha^2 \omega_1^\top \omega_2 + v_1^\top v_2 = \mathcal{V}_1^\top G \mathcal{V}_2
\label{eq:app_inner_product}
\end{equation}
where $G = \mathrm{diag}(\alpha^2 I_3, I_3)$ is the metric tensor. This corresponds to the kinetic energy of an isotropic rigid body with unit mass and moment of inertia $\alpha^2 I_3$:
\begin{equation}
K = \frac{1}{2} \langle \mathcal{V}, \mathcal{V} \rangle_G = \frac{1}{2} \mathcal{V}^\top G \mathcal{V}
\label{eq:app_kinetic_energy_metric}
\end{equation}

\textbf{Physical Interpretation.} The characteristic length $\alpha$ acts as the radius of gyration, representing the ratio between rotational and translational inertia. This metric extends to a left-invariant Riemannian metric on SE(3), whose geodesics correspond to free rigid body motion---providing a dynamically consistent notion of distance on the configuration manifold.

\subsubsection{Riemannian Metric Extension}

We extend the inner product defined on $\mathfrak{se}(3)$ to a left-invariant Riemannian metric on SE(3). For tangent vectors $\dot{T}_1, \dot{T}_2 \in T_T \mathrm{SE}(3)$:
\begin{equation}
\langle \dot{T}_1, \dot{T}_2 \rangle_T = \langle T^{-1}\dot{T}_1, T^{-1}\dot{T}_2 \rangle_G
\label{eq:app_riemannian_metric}
\end{equation}

\subsubsection{Geodesics and Action Minimization}

A geodesic minimizes the action integral along the manifold. For a curve $T(t) \in \mathrm{SE}(3)$ with body twist ${}^b\mathcal{V}_b(t) = (\omega(t), v(t))$, the action integral is:
\begin{equation}
S = \int_{t_0}^{t_f} \langle {}^b\mathcal{V}_b(t), {}^b\mathcal{V}_b(t) \rangle_G \, dt = \int_{t_0}^{t_f} \left( \alpha^2 \|\omega(t)\|^2 + \|v(t)\|^2 \right) dt
\label{eq:app_action_integral}
\end{equation}

The Euler-Poincar\'{e} equations for the decoupled metric $G = \mathrm{diag}(\alpha^2 I_3, I_3)$ yield:
\begin{align}
\alpha^2 \dot{\omega} + \omega \times (\alpha^2 \omega) &= 0 \quad \Rightarrow \quad \dot{\omega} = 0 \label{eq:app_euler_poincare_rot}\\
\dot{v} + \omega \times v &= 0 \quad \Rightarrow \quad \dot{v} = -\omega \times v \label{eq:app_euler_poincare_trans}
\end{align}

Solving with initial conditions $\omega(0) = \omega_0$ and $v(0) = v_0$:
\begin{itemize}
    \item \textbf{Rotation}: $\omega(t) = \omega_0$ (constant angular velocity about a fixed axis in body frame)
    \item \textbf{Translation}: $v(t) = e^{-[\omega_0]_\times t} v_0 = R(t)^\top v_0$ where $R(t) = e^{[\omega_0]_\times t}$
\end{itemize}
These solutions describe the motion of an isotropic rigid body: constant angular velocity with linear velocity maintaining constant direction in the spatial frame.

\subsubsection{Geodesic Distance and Weighted Pose Error}

The geodesic distance between poses $T_{sb}$ and $T_{sd}$ under this metric is:
\begin{equation}
d^2(T_{sb}, T_{sd}) = \alpha^2 \| e_R \|^2 + \| e_p \|^2
\label{eq:app_geodesic_distance}
\end{equation}
where the pose error components in body frame are:
\begin{equation}
e_R = \log(R_{sb}^\top R_{sd})^\vee \in \mathbb{R}^3, \quad e_p = R_{sb}^\top(p_{sd} - p_{sb}) \in \mathbb{R}^3
\label{eq:app_pose_error_components}
\end{equation}

The \textbf{weighted pose error vector} (matching Eq.~\eqref{eq:pose_error} in the main text):
\begin{equation}
\mathcal{E} = \begin{pmatrix} \alpha \, e_R \\ e_p \end{pmatrix} \in \mathbb{R}^6
\label{eq:app_weighted_error}
\end{equation}
satisfies $\|\mathcal{E}\|^2 = d^2(T_{sb}, T_{sd})$, providing a Euclidean representation whose norm equals the SE(3) geodesic distance.

%==============================================================================
\subsection{Virtual Mass-Spring-Damper System on SE(3)}
\label{app:virtual_system}
%==============================================================================

Classical impedance control designs a virtual mechanical system that governs the end-effector's interaction behavior. We derive this system from energy principles.

\subsubsection{Potential Energy of Pose Error}

We define the potential energy as a quadratic function of the weighted pose error using a symmetric positive semi-definite stiffness matrix $K \in \mathbb{R}^{6 \times 6}$:
\begin{equation}
P(\mathcal{E}) = \frac{1}{2} \mathcal{E}^\top K \, \mathcal{E}
\label{eq:app_potential_energy}
\end{equation}

This potential energy reaches its minimum ($P = 0$) when $\mathcal{E} = 0$, i.e., when the current pose matches the desired pose.

\subsubsection{Pose-Error Jacobian and Elastic Wrench Derivation}
\label{app:error_jacobian}

We derive the elastic wrench using the \textbf{power duality principle}. The key is to establish the relationship between the rate of change of the weighted pose error and the body twist through an error Jacobian matrix.

For regulation tasks with static desired pose ($\dot{T}_{sd} = 0$), we derive the error time derivatives in terms of body twist ${}^b\mathcal{V}_b = (\omega_b, v_b)$.

\textbf{Translation Error Rate.} With $e_p = R_{sb}^\top(p_{sd} - p_{sb})$, using $\dot{R}_{sb} = R_{sb}[\omega_b]_\times$ and $\dot{p}_{sb} = R_{sb} v_b$:
\begin{equation}
\begin{aligned}
\dot{e}_p &= \frac{d}{dt}(R_{sb}^\top)(p_{sd} - p_{sb}) + R_{sb}^\top(\dot{p}_{sd} - \dot{p}_{sb}) \\
&= (R_{sb}[\omega_b]_\times)^\top(p_{sd} - p_{sb}) - R_{sb}^\top R_{sb} v_b \\
&= [\omega_b]_\times^\top e_p - v_b = -[\omega_b]_\times e_p - v_b = [e_p]_\times \omega_b - v_b
\end{aligned}
\label{eq:app_trans_error_rate}
\end{equation}
where we used $[\omega_b]_\times^\top = -[\omega_b]_\times$ and the identity $-\omega_b \times e_p = [e_p]_\times \omega_b$.

\textbf{Rotation Error Rate.} Let $R_{\mathrm{err}} = R_{sb}^\top R_{sd}$ so that $e_R = \log(R_{\mathrm{err}})^\vee$. Differentiating for static $\dot{R}_{sd} = 0$:
\begin{equation}
\dot{R}_{\mathrm{err}} = \dot{R}_{sb}^\top R_{sd} = (R_{sb}[\omega_b]_\times)^\top R_{sd} = -[\omega_b]_\times R_{sb}^\top R_{sd} = -[\omega_b]_\times R_{\mathrm{err}}
\label{eq:app_rot_error_dynamics}
\end{equation}

From Lie group theory, if $\dot{R} = [\omega_s]_\times R$ then $\dot{\theta} = J_l^{-1}(\theta)\,\omega_s$, where $J_l$ is the left Jacobian of SO(3):
\begin{equation}
J_l(\theta) = I + \frac{1 - \cos\|\theta\|}{\|\theta\|^2}[\theta]_\times + \frac{\|\theta\| - \sin\|\theta\|}{\|\theta\|^3}[\theta]_\times^2
\label{eq:app_left_jacobian}
\end{equation}

Here $\omega_s = -\omega_b$, so:
\begin{equation}
\dot{e}_R = -J_l^{-1}(e_R) \, \omega_b
\label{eq:app_rot_error_rate}
\end{equation}

\textbf{Weighted Error Jacobian.} The weighted error rate is:
\begin{equation}
\dot{\mathcal{E}} = \begin{pmatrix} \alpha \dot{e}_R \\ \dot{e}_p \end{pmatrix} = \begin{pmatrix} -\alpha J_l^{-1}(e_R) \, \omega_b \\ [e_p]_\times \, \omega_b - v_b \end{pmatrix} = -J_{\mathcal{E}} \, {}^b\mathcal{V}_b
\label{eq:app_weighted_error_rate}
\end{equation}
with the \textbf{pose-error Jacobian}:
\begin{equation}
\boxed{J_{\mathcal{E}} = \begin{pmatrix} \alpha J_l^{-1}(e_R) & 0_{3\times 3} \\ -[e_p]_\times & I_3 \end{pmatrix} \in \mathbb{R}^{6 \times 6}}
\label{eq:app_error_jacobian}
\end{equation}

\textbf{Elastic Wrench via Power Duality.} The rate of change of potential energy is:
\begin{equation}
\dot{P} = \frac{\partial P}{\partial \mathcal{E}}^\top \dot{\mathcal{E}} = (K\mathcal{E})^\top \dot{\mathcal{E}} = (K\mathcal{E})^\top (-J_{\mathcal{E}} \, {}^b\mathcal{V}_b) = (-J_{\mathcal{E}}^\top K \mathcal{E})^\top \, {}^b\mathcal{V}_b
\label{eq:app_potential_power}
\end{equation}

By power duality, we define the elastic wrench $\mathcal{F}_{\mathrm{elastic}}$ such that $\dot{P} = {}^b\mathcal{V}_b^\top \mathcal{F}_{\mathrm{elastic}}$, yielding:
\begin{equation}
\boxed{\mathcal{F}_{\mathrm{elastic}} = -J_{\mathcal{E}}^\top K \mathcal{E}}
\label{eq:app_elastic_wrench}
\end{equation}

\textbf{Explicit Components.} Expanding with $\mathcal{E} = (\alpha e_R, e_p)^\top$ and $K = \begin{psmallmatrix} K_{RR} & K_{Rp} \\ K_{pR} & K_{pp} \end{psmallmatrix}$:
\begin{equation}
\mathcal{F}_{\mathrm{elastic}} = \begin{pmatrix} m_{\mathrm{elastic}} \\ f_{\mathrm{elastic}} \end{pmatrix}, \quad
\begin{aligned}
m_{\mathrm{elastic}} &= -\alpha J_l^{-\top}(e_R)(K_{RR}\alpha e_R + K_{Rp} e_p) - e_p \times (K_{pR}\alpha e_R + K_{pp} e_p) \\
f_{\mathrm{elastic}} &= -K_{pR}\alpha e_R - K_{pp} e_p
\end{aligned}
\label{eq:app_elastic_components}
\end{equation}

\subsubsection{Twist Error and Kinetic Energy}
\label{app:twist_error}

Given current body twist ${}^b\mathcal{V}_b$ and desired body twist ${}^d\mathcal{V}_d$, we compute their difference in the current body frame using the Adjoint map. For $T_{bd} = T_{sb}^{-1} T_{sd}$ with $R_{bd} = R_{sb}^\top R_{sd}$ and $p_{bd} = R_{sb}^\top(p_{sd} - p_{sb})$:
\begin{equation}
\mathrm{Ad}_{T_{bd}} = \begin{pmatrix} R_{bd} & 0 \\ [p_{bd}]_\times R_{bd} & R_{bd} \end{pmatrix}
\label{eq:app_adjoint}
\end{equation}

The twist error in the body frame is:
\begin{equation}
\xi = {}^b\mathcal{V}_d - {}^b\mathcal{V}_b = \mathrm{Ad}_{T_{bd}} \, {}^d\mathcal{V}_d - {}^b\mathcal{V}_b
\label{eq:app_twist_error}
\end{equation}

We define the \textbf{kinetic energy of the virtual system} as a quadratic function of the twist error:
\begin{equation}
K_{\mathrm{virtual}}(\xi) = \frac{1}{2} \xi^\top M \xi
\label{eq:app_virtual_kinetic}
\end{equation}
where $M \in \mathbb{R}^{6 \times 6}$ is the positive-definite virtual mass (inertia) matrix.

Assuming $M$ is constant in the body frame, the rate of change of kinetic energy is:
\begin{equation}
\dot{K}_{\mathrm{virtual}} = \frac{d}{dt}\left(\frac{1}{2}\xi^\top M \xi\right) = \xi^\top M \dot{\xi}
\label{eq:app_kinetic_rate}
\end{equation}

The term $M\dot{\xi}$ corresponds to the \textbf{inertial wrench}, analogous to $ma$ in Newton's second law.

\subsubsection{Complete Virtual Dynamics via Power Balance}
\label{app:power_balance}

The complete virtual system follows from the \textbf{power balance equation}. The total energy $E = K_{\mathrm{virtual}} + P$ evolves according to:
\begin{equation}
\dot{E} = P_{\mathrm{ext}} - P_{\mathrm{diss}}
\label{eq:app_energy_balance}
\end{equation}
where:
\begin{itemize}
    \item $P_{\mathrm{ext}} = \mathcal{F}_{\mathrm{ext}}^\top \xi$: External power input (work done by external wrench on the virtual system)
    \item $P_{\mathrm{diss}} = \xi^\top D \xi$: Dissipated power due to damping ($D \in \mathbb{R}^{6\times 6}$ symmetric positive-definite)
\end{itemize}

Expanding the power balance:
\begin{equation}
\frac{d}{dt}\left(\frac{1}{2}\xi^\top M \xi\right) + \frac{d}{dt}\left(\frac{1}{2}\mathcal{E}^\top K \mathcal{E}\right) = \mathcal{F}_{\mathrm{ext}}^\top \xi - \xi^\top D \xi
\label{eq:app_power_balance_expanded}
\end{equation}

Using $\dot{K}_{\mathrm{virtual}} = \xi^\top M \dot{\xi}$ and $\dot{P} = -\mathcal{F}_{\mathrm{elastic}}^\top {}^b\mathcal{V}_b = (J_{\mathcal{E}}^\top K \mathcal{E})^\top {}^b\mathcal{V}_b$:
\begin{equation}
\xi^\top \left[M \dot{\xi} + J_{\mathcal{E}}^\top K \mathcal{E}\right] = \xi^\top \left[\mathcal{F}_{\mathrm{ext}} - D\xi\right]
\label{eq:app_power_balance_factored}
\end{equation}

Since this must hold for all $\xi$, we obtain the \textbf{virtual mass-spring-damper dynamics}:
\begin{equation}
\boxed{M \dot{\xi} + D\xi + J_{\mathcal{E}}^\top K \mathcal{E} = \mathcal{F}_{\mathrm{ext}}}
\label{eq:app_virtual_dynamics}
\end{equation}

\textbf{Physical Interpretation:}
\begin{itemize}
    \item $M \dot{\xi}$: Inertial term (virtual mass effect resisting acceleration)
    \item $D \xi$: Damping term (energy dissipation proportional to velocity error)
    \item $J_{\mathcal{E}}^\top K \mathcal{E}$: Elastic wrench (restoring force toward desired pose)
    \item $\mathcal{F}_{\mathrm{ext}}$: External excitation from environment contact
\end{itemize}

%==============================================================================
\subsection{The Pose-Error Jacobian Problem}
\label{app:jacobian_problem}
%==============================================================================

The Jacobian $J_{\mathcal{E}}$ in Eq.~\eqref{eq:app_error_jacobian} introduces significant complexity:

\begin{enumerate}
    \item \textbf{Nonlinear transcendental functions}: $J_l^{-1}(e_R)$ involves $\sin\|e_R\|$, $\cos\|e_R\|$, and $\|e_R\|^{-1}$ terms that are expensive to compute and differentiate.
    
    \item \textbf{Configuration-dependent coupling}: The $-[e_p]_\times$ block couples rotation and translation in ways that depend on the current pose error.
    
    \item \textbf{Approximation failure}: The common approximation $J_l^{-1}(e_R) \approx I_3$ (valid for small $\|e_R\| \ll 1$) fails in bimanual manipulation where constraint violations can cause large trajectory deviations.
    
    \item \textbf{Non-diagonal stiffness requirements}: Object-aware motion decomposition requires non-diagonal $K$ matrices, making the full $J_{\mathcal{E}}^\top K \mathcal{E}$ computation unavoidable.
\end{enumerate}

This nonlinearity is the core challenge referenced in Section~\ref{sec:problem_setup} (\textbf{C3}) that SWIVL addresses.

%==============================================================================
\subsection{Impedance Controller Implementation}
\label{app:controller_implementation}
%==============================================================================

\subsubsection{Operational Space Dynamics}

The robot's joint space dynamics:
\begin{equation}
M(q)\ddot{q} + C(q,\dot{q})\dot{q} + g(q) = \tau - J_b^\top \mathcal{F}_{\mathrm{ext}}
\label{eq:app_joint_dynamics}
\end{equation}
transform to operational space via the body Jacobian $J_b(q)$ with ${}^b\mathcal{V}_b = J_b(q)\dot{q}$:
\begin{equation}
\Lambda_b(q) \dot{\mathcal{V}}_b + \mu_b(q,\dot{q}) + \gamma_b(q) = \mathcal{F}_{\mathrm{cmd}} - \mathcal{F}_{\mathrm{ext}}
\label{eq:app_op_space_dynamics}
\end{equation}
where:
\begin{itemize}
    \item $\Lambda_b = (J_b M^{-1} J_b^\top)^{-1}$: Operational space inertia (symmetric positive-definite)
    \item $\mu_b = \Lambda_b J_b M^{-1} C\dot{q} - \Lambda_b \dot{J}_b \dot{q}$: Coriolis/centrifugal wrench
    \item $\gamma_b = \Lambda_b J_b M^{-1} g$: Gravity wrench in body frame
    \item $\mathcal{F}_{\mathrm{cmd}}$: Control wrench, related to joint torques by $\tau = J_b^\top \mathcal{F}_{\mathrm{cmd}}$
\end{itemize}

\subsubsection{Controller Design via Virtual-Robot Coupling}

To achieve desired impedance behavior, we couple the virtual system dynamics with the robot's operational space dynamics. The key is to match the closed-loop robot behavior to the virtual mass-spring-damper system.

We have two dynamic systems:
\begin{itemize}
    \item \textbf{Virtual System}: $M \dot{\xi} + D \xi + J_{\mathcal{E}}^\top K \mathcal{E} = \mathcal{F}_{\mathrm{ext}}$
    \item \textbf{Robot Dynamics}: $\Lambda_b \dot{\mathcal{V}}_b + \mu_b + \gamma_b = \mathcal{F}_{\mathrm{cmd}} - \mathcal{F}_{\mathrm{ext}}$
\end{itemize}

Recall $\xi = {}^b\mathcal{V}_d - {}^b\mathcal{V}_b$, so $\dot{\xi} = {}^b\dot{\mathcal{V}}_d - {}^b\dot{\mathcal{V}}_b$.

\textbf{Step 1}: Solve for $\dot{\xi}$ from virtual system:
\begin{equation}
\dot{\xi} = -M^{-1}(D\xi + J_{\mathcal{E}}^\top K \mathcal{E} - \mathcal{F}_{\mathrm{ext}})
\end{equation}

\textbf{Step 2}: Substitute into $\dot{\xi} = {}^b\dot{\mathcal{V}}_d - {}^b\dot{\mathcal{V}}_b$ and solve for ${}^b\dot{\mathcal{V}}_b$:
\begin{equation}
{}^b\dot{\mathcal{V}}_b = {}^b\dot{\mathcal{V}}_d + M^{-1}(D\xi + J_{\mathcal{E}}^\top K \mathcal{E} - \mathcal{F}_{\mathrm{ext}})
\end{equation}

\textbf{Step 3}: Substitute into robot dynamics:
\begin{equation}
\Lambda_b\left[{}^b\dot{\mathcal{V}}_d + M^{-1}(D\xi + J_{\mathcal{E}}^\top K \mathcal{E} - \mathcal{F}_{\mathrm{ext}})\right] + \mu_b + \gamma_b = \mathcal{F}_{\mathrm{cmd}} - \mathcal{F}_{\mathrm{ext}}
\end{equation}

\textbf{Step 4}: Solve for control wrench:
\begin{equation}
\boxed{\mathcal{F}_{\mathrm{cmd}} = \Lambda_b M^{-1}(D\xi + J_{\mathcal{E}}^\top K \mathcal{E}) + \Lambda_b {}^b\dot{\mathcal{V}}_d + \mu_b + \gamma_b + (I - \Lambda_b M^{-1})\mathcal{F}_{\mathrm{ext}}}
\label{eq:app_general_controller}
\end{equation}

\textbf{Controller Components:}
\begin{itemize}
    \item $\Lambda_b M^{-1}(D\xi + J_{\mathcal{E}}^\top K \mathcal{E})$: Impedance feedback with weighted error Jacobian
    \item $\Lambda_b {}^b\dot{\mathcal{V}}_d$: Feedforward acceleration term
    \item $\mu_b + \gamma_b$: Coriolis and gravity compensation
    \item $(I - \Lambda_b M^{-1})\mathcal{F}_{\mathrm{ext}}$: External force compensation (inertia-dependent)
\end{itemize}

\subsubsection{Simplified Cases}

\textbf{Case 1: $M = \Lambda_b$} (virtual mass matches robot inertia):
\begin{equation}
\mathcal{F}_{\mathrm{cmd}} = D\xi + J_{\mathcal{E}}^\top K \mathcal{E} + \Lambda_b {}^b\dot{\mathcal{V}}_d + \mu_b + \gamma_b
\label{eq:app_simplified_1}
\end{equation}

\textbf{Case 2: $M = \Lambda_b$ and ${}^b\dot{\mathcal{V}}_d = 0$} (regulation task):
\begin{equation}
\mathcal{F}_{\mathrm{cmd}} = D\xi + J_{\mathcal{E}}^\top K \mathcal{E} + \mu_b + \gamma_b
\label{eq:app_simplified_2}
\end{equation}

\textbf{Case 3: Small rotation errors} ($\|e_R\| \ll 1$ so $J_l^{-1} \approx I_3$) with isotropic stiffness ($K = kI_6$):
\begin{equation}
J_{\mathcal{E}} \approx \begin{pmatrix} \alpha I_3 & 0 \\ -[e_p]_\times & I_3 \end{pmatrix}, \quad
\mathcal{F}_{\mathrm{cmd}} = D\xi + K_\alpha \mathcal{E} + \mu_b + \gamma_b
\label{eq:app_simplified_3}
\end{equation}
where $K_\alpha = \mathrm{diag}(\alpha k I_3, k I_3)$ recovers the familiar linear impedance form.

%==============================================================================
\subsection{SWIVL's Twist-Driven Approach}
\label{app:swivl_approach}
%==============================================================================

SWIVL bypasses $J_{\mathcal{E}}$ by incorporating pose errors directly into reference twists rather than computing elastic wrenches explicitly.

\subsubsection{Reference Twist with Pose Error Correction}

Recall from Section~\ref{sec:reference_twist_field} that SWIVL constructs a reference twist (Eq.~\eqref{eq:vector_field}):
\begin{equation}
\mathcal{V}_i^{\mathrm{ref}} = \mathrm{Ad}_{T_{b_id_i}} \mathcal{V}_i^{\mathrm{des}} + k_{p_i} \mathcal{E}_i
\label{eq:app_ref_twist}
\end{equation}
where $\mathcal{E}_i = (\alpha e_{R_i}, e_{p_i})^\top$ is the weighted pose error.

\subsubsection{Controller Formulation}

SWIVL's commanded wrench (Eq.~\eqref{eq:impedance_control_main}) is:
\begin{equation}
\mathcal{F}_{\mathrm{cmd},i} = K_{d_i}(\mathcal{V}_i^{\mathrm{ref}} - \mathcal{V}_i) + \mu_{b,i} + \gamma_{b,i}
\label{eq:app_swivl_cmd}
\end{equation}
where $K_{d_i} = G(P_{i,\parallel} d_{i,\parallel} + P_{i,\perp} d_{i,\perp})$ is the decomposed damping matrix.

\subsubsection{Equivalence to SE(3) Impedance}

Expanding Eq.~\eqref{eq:app_swivl_cmd} with the reference twist definition:
\begin{align}
\mathcal{F}_{\mathrm{cmd},i} &= K_{d_i}(\mathrm{Ad}_{T_{b_id_i}} \mathcal{V}_i^{\mathrm{des}} - \mathcal{V}_i + k_{p_i} \mathcal{E}_i) + \mu_{b,i} + \gamma_{b,i} \nonumber \\
&= K_{d_i} \xi_i + K_{d_i} k_{p_i} \mathcal{E}_i + \mu_{b,i} + \gamma_{b,i}
\label{eq:app_expanded}
\end{align}
where $\xi_i = \mathrm{Ad}_{T_{b_id_i}} \mathcal{V}_i^{\mathrm{des}} - \mathcal{V}_i$ is the twist error.

Comparing with the classical impedance controller (Eq.~\eqref{eq:app_simplified_2}):
\begin{equation}
\mathcal{F}_{\mathrm{cmd}} = D\xi + J_{\mathcal{E}}^\top K \mathcal{E} + \mu_b + \gamma_b
\end{equation}

The correspondence is:
\begin{equation}
\underbrace{K_{d_i}}_{\text{learned } D} \xi_i + \underbrace{K_{d_i} k_{p_i} \mathcal{E}_i}_{\approx J_{\mathcal{E}}^\top K \mathcal{E}} + \mu_{b,i} + \gamma_{b,i}
\end{equation}

\textbf{Key Insight.} SWIVL replaces the explicit nonlinear term $J_{\mathcal{E}}^\top K \mathcal{E}$ with $K_{d_i} k_{p_i} \mathcal{E}_i$, which:
\begin{itemize}
    \item Avoids computing $J_l^{-1}(e_R)$ and its configuration-dependent coupling
    \item Maintains impedance behavior through the pose error correction in the reference twist
    \item Enables the RL policy to learn appropriate $k_{p_i}$ values that adapt to task requirements
\end{itemize}

Under small rotation errors where $J_l^{-1}(e_R) \approx I_3$, the approximation $J_{\mathcal{E}} \approx \mathrm{diag}(\alpha I_3, I_3)$ shows that $K_{d_i} k_{p_i} \mathcal{E}_i \approx k_{p_i} G \mathcal{E}_i$, recovering a diagonal stiffness structure. For larger errors, the learned $k_{p_i}$ compensates for the approximation.

%==============================================================================
%==============================================================================
\section{SE(3) Trajectory Interpolation}
\label{app:trajectory_interpolation}
%==============================================================================
%==============================================================================

This appendix details the SE(3) trajectory smoothing procedure used in the Reference Twist Field Generator (Section~\ref{sec:reference_twist_field}, Step 1).

\subsection{Problem Setup}

Given sparse waypoints $\{T_{sd_i}[\tau]\}_{\tau=0}^{H}$ from high-level policies at frequency $f_{\mathrm{HL}} \sim 10$~Hz, we generate dense trajectories at control frequency $f_{\mathrm{LL}} \sim 100$~Hz while ensuring:
\begin{enumerate}
    \item Continuous position and orientation trajectories
    \item Differentiable trajectories for twist computation (Eq.~\eqref{eq:body_twist})
    \item Geometric consistency on SE(3)
\end{enumerate}

\subsection{Rotational Interpolation: SLERP}
\label{app:slerp}

For rotation matrices $R_0, R_1 \in \mathrm{SO}(3)$ at consecutive waypoints, we use Spherical Linear Interpolation (SLERP) via the exponential map.

\subsubsection{Formulation}

The interpolated rotation at $t \in [0, 1]$ is:
\begin{equation}
R(t) = R_0 \exp\left(t \cdot \log(R_0^\top R_1)\right)
\label{eq:app_slerp}
\end{equation}
where $\log: \mathrm{SO}(3) \to \mathfrak{so}(3)$ and $\exp: \mathfrak{so}(3) \to \mathrm{SO}(3)$ are the matrix logarithm and exponential.

\subsubsection{Angular Velocity}

Differentiating Eq.~\eqref{eq:app_slerp}, the body angular velocity is constant:
\begin{equation}
\omega(t) = \frac{1}{\Delta t} \log(R_0^\top R_1)^\vee
\end{equation}
where $\Delta t$ is the time interval between waypoints. This matches the geodesic solution in Appendix~\ref{app:metric}.

\subsubsection{Quaternion Implementation}

For numerical stability, we implement SLERP using unit quaternions $\mathbf{q}_0, \mathbf{q}_1 \in S^3$:
\begin{equation}
\mathbf{q}(t) = \frac{\sin((1-t)\Omega)}{\sin\Omega} \mathbf{q}_0 + \frac{\sin(t\Omega)}{\sin\Omega} \mathbf{q}_1
\end{equation}
where $\cos\Omega = \mathbf{q}_0 \cdot \mathbf{q}_1$. When $\Omega \approx 0$, we use linear interpolation.

\subsection{Translational Interpolation: Cubic Splines}
\label{app:cubic_spline}

For position waypoints $\{p_0, p_1, \ldots, p_H\}$ at times $\{t_0, t_1, \ldots, t_H\}$, we construct a cubic spline ensuring $C^2$ continuity.

\subsubsection{Spline Construction}

On each interval $[t_k, t_{k+1}]$, the position is:
\begin{equation}
p(t) = a_k + b_k(t - t_k) + c_k(t - t_k)^2 + d_k(t - t_k)^3
\end{equation}
with coefficients determined by:
\begin{itemize}
    \item Interpolation: $p(t_k) = p_k$, $p(t_{k+1}) = p_{k+1}$
    \item $C^1$ continuity: Velocity continuity at interior knots
    \item $C^2$ continuity: Acceleration continuity at interior knots
    \item Boundary conditions: Natural spline ($p''(t_0) = p''(t_H) = 0$) or clamped
\end{itemize}

\subsubsection{Velocity and Acceleration}

The derivatives are:
\begin{align}
\dot{p}(t) &= b_k + 2c_k(t - t_k) + 3d_k(t - t_k)^2 \\
\ddot{p}(t) &= 2c_k + 6d_k(t - t_k)
\end{align}
providing the spatial linear velocity needed for twist computation.

\subsection{Body Twist Computation}

Given interpolated $R(t)$ and $p(t)$, the desired body twist (Eq.~\eqref{eq:body_twist}) is:
\begin{equation}
\mathcal{V}^{\mathrm{des}}(t) = \begin{pmatrix} \omega^{\mathrm{des}}(t) \\ v^{\mathrm{des}}(t) \end{pmatrix}, \quad
[\omega^{\mathrm{des}}]_\times = R(t)^\top \dot{R}(t), \quad
v^{\mathrm{des}} = R(t)^\top \dot{p}(t)
\end{equation}

For SLERP rotations, $\omega^{\mathrm{des}}$ is piecewise constant. For cubic spline translations, $v^{\mathrm{des}}$ is piecewise quadratic in the spatial frame (and smooth in the body frame after the rotation transformation).

\subsection{Implementation Notes}

\begin{enumerate}
    \item \textbf{Waypoint timing}: Equal spacing $\Delta t = 1/f_{\mathrm{HL}}$ between high-level waypoints
    \item \textbf{Interpolation frequency}: Dense samples at $\Delta t_{\mathrm{LL}} = 1/f_{\mathrm{LL}}$
    \item \textbf{Action chunk handling}: For action chunks of horizon $H_{\mathrm{chunk}}$, we interpolate over the full chunk and update when new chunks arrive
    \item \textbf{Singularity handling}: When $R_0 \approx R_1$ (small rotation), use first-order approximation $R(t) \approx R_0(I + t[\omega]_\times)$
\end{enumerate}