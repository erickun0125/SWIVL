% Experiments - Simplified Version
\section{Experiments}
\label{sec:experiments}

We evaluate SWIVL on bimanual manipulation of articulated objects in an SE(2) planar benchmark. Our experiments aim to verify whether SWIVL improves task success and reduces fighting forces, comparing its performance against high stiffness position control and linearized impedance control.

%------------------------------------------------------------------------------
\subsection{Experimental Setup}
\label{sec:exp_setup}
%------------------------------------------------------------------------------

\paragraph{SE(2) Benchmark Rationale.}
While our method (Section~\ref{sec:method}) is formulated for SE(3) with $k$-DoF articulated objects, we validate in SE(2) with 1-DoF objects. This deliberate simplification enables rigorous evaluation while preserving the essential challenges: \textbf{(i)} the fundamental phenomena---force coupling, constraint satisfaction, compliant coordination---manifest identically in planar and spatial settings; \textbf{(ii)} all architectural components (projection operators $P_{i,\parallel}, P_{i,\perp}$, metric tensor $G(\alpha)$, impedance modulation $d_\parallel, d_\perp$) remain fully exercised; and \textbf{(iii)} the mathematical structure (Lie group, screw theory, twist-wrench duality) reduces consistently from SE(3). Extension to SE(3) requires only scaling observation/action dimensions. See Appendix~\ref{app:se2} for complete SE(2) instantiation.

\paragraph{Environment.}
We introduce \textbf{BiarT} (Bimanual Articulated manipulation), a Pymunk-based SE(2) simulation environment for bimanual manipulation of articulated objects. Just as \textbf{PushT}~\cite{chi2023diffusion} serves as a minimal benchmark for single-arm planar manipulation, BiarT provides a lightweight testbed for studying the unique challenges of bimanual coordination---force coupling, constraint satisfaction, and compliant control---without the complexity of full 3D physics. The environment features a 512$\times$512 pixel planar workspace with dual 3-DoF end-effectors under direct body wrench control $\mathcal{F}_i = [m_z, f_x, f_y]^\top$. Each end-effector provides 3-axis F/T sensing. The hierarchical architecture combines high-level planning (10 Hz) with low-level control (100 Hz).

\paragraph{Tasks and Objects.}
We evaluate on \textbf{2 articulated objects} spanning two joint types (Figure~\ref{fig:objects}):
\begin{itemize}[leftmargin=1.5em]
    \item \textbf{Revolute}: Angular articulation---rotation about a pivot point. One arm drives rotation while the other must comply.
    \item \textbf{Prismatic}: Linear articulation---sliding along an axis. One arm drives extension/retraction while the other accommodates.
\end{itemize}
Each object satisfies the SE(2) holonomic constraint ${}^s\mathcal{V}_l - {}^s\mathcal{V}_r = \mathcal{S}\dot{q}_{obj}$ with constant body-frame screw axes $\mathcal{B}_l, \mathcal{B}_r \in \mathbb{R}^3$. Tasks require manipulating objects from randomized initial configurations to goal configurations. \textbf{Success criteria}: position error $<$10 pixels, orientation error $<$5°, joint error $<$5° or 5 pixels, with maintained grasp. Each configuration is tested over \textbf{10 trials}.

\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{figures/objects.jpg}
    \caption{\textbf{Benchmark objects.} Two SE(2) articulated objects spanning two joint types: revolute (angular articulation) and prismatic (linear articulation). Red and Blue end-effectors are floating base parallel grippers.} 
    \label{fig:objects}
\end{figure}

\paragraph{High-Level Planner.}
All methods share a common high-level planner: a \textbf{Flow Matching Policy} trained via behavior cloning on expert demonstrations. The policy outputs action chunks---sequences of desired end-effector poses $\{T_{sd_i}[\tau]\}_{\tau=0}^{H}$---at 10 Hz. This architecture represents state-of-the-art imitation learning for manipulation, providing temporally consistent motion intentions without explicit reasoning about contact dynamics or inter-arm force coordination. By fixing the high-level planner across all methods, we isolate the contribution of the low-level control strategy.

\paragraph{Methods Under Comparison.}
We compare three low-level control strategies, all receiving identical action chunks from the Flow Matching Policy:

\begin{itemize}[leftmargin=1.5em]
    \item \textbf{Position Control (Pos-Ctrl)}: The action chunks are tracked via high-stiffness position control. This represents the standard deployment of imitation learning policies, where learned poses are directly executed without force awareness. The controller applies:
    \begin{equation}
        \mathcal{F}_{cmd,i} = K_p (p_{d_i} - p_i) + K_d (\dot{p}_{d_i} - \dot{p}_i)
    \end{equation}
    with high gains $K_p, K_d$ to minimize tracking error, prioritizing trajectory fidelity over compliance.
    
    \item \textbf{Impedance Control (Imp-Ctrl)}: The action chunks are tracked via linearized SE(2) impedance control with linearized approximations. This baseline employs the standard mass-spring-damper formulation:
    \begin{equation}
        \mathcal{F}_{cmd,i} = D\xi_i + K\mathcal{E}_i + \mu_{b,i}
    \end{equation}
    where $\xi_i$ is the twist error, $\mathcal{E}_i$ is the pose error, and $D, K$ are fixed diagonal damping and stiffness matrices. This approach assumes small orientation errors ($J_l^{-1}(e_R) \approx I_3$) and uses isotropic impedance parameters without object-aware decomposition.
    
    \item \textbf{SWIVL (Ours)}: The action chunks are processed through the full SWIVL framework: (i) the Reference Twist Field Generator converts sparse waypoints into dense, stable reference twists with pose-error correction, (ii) the RL policy modulates impedance variables $(d_{i,\parallel}, d_{i,\perp}, k_{p_i}, \alpha)$ conditioned on screw axes and wrench feedback, and (iii) the Screw-Decomposed Impedance Controller executes compliant control with independent regulation of bulk and internal motions.
\end{itemize}

\paragraph{Implementation.}
For SWIVL, the policy observes reference twists $\mathcal{V}_i^{\text{ref}}$, screw axes $\mathcal{B}_i$, wrenches $\mathcal{F}_i$, and proprioception ($\mathbb{R}^{30}$ total), and outputs impedance variables $(d_{l,\parallel}, d_{r,\parallel}, d_{l,\perp}, d_{r,\perp}, k_{p_l}, k_{p_r}, \alpha) \in \mathbb{R}^7$. Training uses PPO with the reward from Eq.~\eqref{eq:reward}. For fair comparison, Imp-Ctrl uses the same control frequency (100 Hz) and receives identical trajectory inputs. Full architecture and hyperparameters are in Appendix~\ref{app:learning_settings}.

\paragraph{Metrics.}
\begin{itemize}[leftmargin=1.5em]
    \item \textbf{Success Rate} (\%): Task completion within error thresholds and time limit
    \item \textbf{Wrench Limit Failure} (\%): Episodes terminated due to exceeding safe wrench thresholds
    \item \textbf{Grasp Drift Failure} (\%): Episodes terminated due to grasp instability causing object loss
    \item \textbf{Timeout Failure} (\%): Episodes where task was not completed within time limit (implicitly computed as $100 - \text{Success} - \text{Wrench Limit} - \text{Grasp Drift}$); these represent performance failures without safety violations
\end{itemize}

%------------------------------------------------------------------------------
\subsection{Results}
\label{sec:results}
%------------------------------------------------------------------------------

% ============================================================================
% TABLE: Main comparison results
% ============================================================================
\begin{table}[t]
\centering
\caption{\textbf{Quantitative comparison.} Performance across two joint types (10 trials each). All methods use the same Flow Matching Policy as high-level planner. Bold indicates best. Timeout failures (not shown) are implicitly $100 - \text{Success} - \text{Wrench} - \text{Grasp}$.}
\label{tab:main_results}
\small
\begin{tabular}{lccc}
\toprule
\textbf{Method} & \textbf{Success (\%)$\uparrow$} & \textbf{Wrench Fail (\%)$\downarrow$} & \textbf{Grasp Fail (\%)$\downarrow$} \\
\midrule
\multicolumn{4}{l}{\textit{Revolute Joint}} \\
Pos-Ctrl & 10 & 70 & 0 \\
Imp-Ctrl & 10 & 20 & 30 \\
SWIVL (Ours) & \textbf{40} & \textbf{0} & \textbf{10} \\
\midrule
\multicolumn{4}{l}{\textit{Prismatic Joint}} \\
Pos-Ctrl & 30 & 40 & 0 \\
Imp-Ctrl & 60 & 0 & 20 \\
SWIVL (Ours) & \textbf{80} & \textbf{0} & \textbf{0} \\
\midrule
\multicolumn{4}{l}{\textit{Average (All Objects)}} \\
Pos-Ctrl & 20 & 55 & 0 \\
Imp-Ctrl & 35 & 10 & 25 \\
SWIVL (Ours) & \textbf{60} & \textbf{0} & \textbf{5} \\
\bottomrule
\end{tabular}
\end{table}

Table~\ref{tab:main_results} presents quantitative results across all joint types. We observe consistent patterns across the two object categories. Figure~\ref{fig:swivl_inference} illustrates a successful manipulation sequence using the full SWIVL framework, demonstrating coordinated bimanual control with learned impedance modulation.

\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{figures/swivl_inference.jpg}
    \caption{\textbf{SWIVL inference sequence.} Time-ordered frames showing successful bimanual manipulation of an articulated object. The impedance parameters panel (left) displays learned values: damping coefficients $d_\parallel, d_\perp$ for internal and bulk motions, stiffness $k_p$, and characteristic length $\alpha$. Red arrows indicate wrench feedback from F/T sensors. The policy adaptively modulates compliance to achieve coordinated manipulation while maintaining low fighting forces.}
    \label{fig:swivl_inference}
\end{figure}

\paragraph{Success Rate.}
SWIVL achieves the highest success rates across both joint types, with an average improvement of 40\% over Pos-Ctrl and 25\% over Imp-Ctrl. The performance gap is particularly pronounced for the revolute joint, where rotational constraints impose stricter coordination requirements that constraint-unaware controllers cannot satisfy.

\paragraph{Wrench Limit Failures.}
Pos-Ctrl exhibits the highest wrench limit failure rates (55\% average) because high-stiffness tracking of kinematically inconsistent references directly translates to excessive inter-arm stress that exceeds safe operating thresholds. This is particularly severe for the revolute joint (70\%), where rotational constraints amplify force coupling. Imp-Ctrl reduces these failures to 10\% through passive compliance. SWIVL achieves zero wrench limit failures by explicitly decomposing wrenches into productive (along constraint) and non-productive (orthogonal) components, then learning to suppress the latter through impedance modulation.

\paragraph{Grasp Drift Failures.}
Interestingly, Imp-Ctrl exhibits the highest grasp drift failures (25\% average) despite having lower wrench failures than Pos-Ctrl. This reveals a fundamental trade-off: isotropic compliance reduces peak forces but introduces uncontrolled motion that destabilizes the grasp over time. Pos-Ctrl shows zero grasp drift because its rigid tracking prevents gradual slip---though this comes at the cost of wrench limit violations. SWIVL achieves only 5\% grasp drift by using screw-decomposed control that selectively applies compliance along constraint directions while maintaining stability orthogonal to them.

\paragraph{Timeout Failures.}
The remaining failures (not shown in Table~\ref{tab:main_results}) are timeout failures---episodes where the task was not completed within the time limit without any safety violations. Notably, SWIVL has higher timeout rates (35\% average) than Pos-Ctrl (25\%) and Imp-Ctrl (30\%), which reflects a deliberate trade-off: by prioritizing safety through learned compliance, SWIVL may occasionally be more conservative in its motions. However, this ``safe but slow'' behavior is preferable in real-world deployment where safety violations can cause hardware damage or task failure.

% ============================================================================
% FIGURE PLACEHOLDER: Force profiles comparison
% ============================================================================
% \begin{figure}[t]
%     \centering
%     \includegraphics[width=\linewidth]{figures/force_comparison.pdf}
%     \caption{\textbf{Fighting force profiles.} Time evolution of bulk wrench magnitude $\|\mathcal{F}_{i,\perp}\|$ during revolute manipulation. Pos-Ctrl exhibits persistent high forces throughout; Imp-Ctrl reduces magnitude but cannot eliminate constraint-violating components; SWIVL maintains consistently low fighting forces through learned impedance modulation.}
%     \label{fig:force_comparison}
% \end{figure}
% ============================================================================

%------------------------------------------------------------------------------
\subsection{Analysis}
\label{sec:analysis}
%------------------------------------------------------------------------------

\paragraph{Why Position Control Fails.}
Position control's fundamental limitation is its inability to accommodate kinematic constraints. When the high-level Flow Matching Policy outputs action chunks, these represent motion \textit{intentions} learned from demonstrations---they do not guarantee kinematic consistency between the two arms. Under high-stiffness control, even small inconsistencies ($<$1\% position error) accumulate into substantial fighting forces because the controller treats the reference as a hard constraint to be achieved regardless of physical consequences. This is particularly problematic for articulated objects where the holonomic constraint ${}^s\mathcal{V}_l - {}^s\mathcal{V}_r = \mathcal{S}\dot{q}_{obj}$ must be satisfied continuously. Figure~\ref{fig:failure_modes} illustrates two representative failure modes: (a) grasp drift caused by excessive fighting forces that destabilize the grasp (Figure~\ref{fig:failure_grasp_drift}), and (b) wrench limit violations where uncontrolled forces exceed safe operating thresholds (Figure~\ref{fig:failure_wrench_limit}).

\paragraph{Why Classical Impedance Control Is Insufficient.}
Classical impedance control introduces compliance but suffers from two key limitations in our setting:
\begin{enumerate}[leftmargin=1.5em]
    \item \textbf{Linearization errors}: The approximation $J_l^{-1}(e_R) \approx I_3$ assumes small orientation errors, which is violated during articulated manipulation where constraint mismatches can cause large trajectory deviations.
    \item \textbf{Lack of object awareness}: Fixed isotropic impedance parameters cannot distinguish between motion along the object's kinematic constraint (which should be compliant) and motion orthogonal to it (which may require stiffness for stability). This one-size-fits-all approach is fundamentally mismatched to articulated object manipulation.
\end{enumerate}

\begin{figure}[t]
    \centering
    \begin{subfigure}[t]{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{figures/failure_grasp_drift.jpg}
        \caption{Grasp drift failure}
        \label{fig:failure_grasp_drift}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{figures/failure_wrench_limit.jpg}
        \caption{Wrench limit exceeded}
        \label{fig:failure_wrench_limit}
    \end{subfigure}
    \caption{\textbf{Failure modes in experiments.} (a) \textit{Grasp drift} (b) \textit{Wrench limit exceeded}}
    \label{fig:failure_modes}
\end{figure}

\paragraph{SWIVL's Advantages.}
SWIVL addresses these limitations through three mechanisms:
\begin{enumerate}[leftmargin=1.5em]
    \item \textbf{Twist-driven formulation}: By incorporating pose errors into reference twists rather than computing elastic wrenches explicitly, SWIVL bypasses the nonlinear pose-error Jacobian $J_E$.
    \item \textbf{Screw-decomposed control}: The projection operators $P_{i,\parallel}, P_{i,\perp}$ partition the twist space into object-centric subspaces, enabling independent compliance for internal versus bulk motions.
    \item \textbf{Learned impedance modulation}: The RL policy discovers task-appropriate impedance strategies conditioned on real-time wrench feedback and object geometry, adapting compliance dynamically rather than relying on fixed parameters.
\end{enumerate}

%------------------------------------------------------------------------------
